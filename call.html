<!DOCTYPE html>
<html>
<head>
    <title>call跟apply</title>
    <script type="text/javascript" src="jquery.js"></script>
</head>
<body>
	<p>fun.call(thisArg,arg1, arg2)；</p>
	<p>描述：可以让call()中的 对象 调用 当前对象所拥有的function。可以实现继承。
	可以使用call()来实现继承：写一个方法(fun)，然后让另外一个新的对象(thisArg)来继承它（而不是在新对象中再写一次这个方法）。</p>
	<p>thisArg在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</p>
	<p>arg1, arg2, ...指定的参数列表。</p>
    <script type="text/javascript">
		function Product(name, price) {
		    this.name = name;
		    this.price = price;

		    if (price < 0) {
		    	throw RangeError('Cannot create product ' +
		                      this.name + ' with a negative price');
		  	}
		}

		function Food() {
			//this则代表着food，用food去调用product这个function

			// 第一种调用方法
		  	Product.call(this, name, price);   //call()中的对象（food构造函数）调用当前对象（Product构造函数）所拥有的function
		  	// Product.call
		  	this.category = 'food';
		}
		// //等同于
		// function Food(name, price) { 
		//     this.name = name;
		//     this.price = price;
		//     if (price < 0) {
		//         throw RangeError('Cannot create product ' +
		//                 this.name + ' with a negative price');
		//     }

		//     this.category = 'food'; 
		// }

		//function Toy 同上
		function Toy(name, price) {
		  	Product.call(this, name, price);
		  	this.category = 'toy';
		}

		var cheese = new Food();
		var fun = new Toy('robot', 40);
		// 第二种调用方法
		Product.call(cheese,'feta',5);
    </script>
</body>
</html>